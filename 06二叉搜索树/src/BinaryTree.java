/**
 * @author boyas
 * @create 2021/6/25 22:30
 */
//二叉树（binary tree)的特点
//    每个结点的度最大为2（最多拥有2棵子树）
//    左子树和右子树是有顺序的
//    即使某结点只有一棵子树，也要区分左右子树
//    二叉树是有有序树还是无序树？有序树
//二叉树的性质
//非空二叉树的第i层，最多有2^(i-1)个结点（i>=1)
//在高度为h的二叉树上最多有2^h-1个结点
//对于任何一颗非空二叉树，如果叶子结点个数为n0,度为2的结点个数为n2，则有：n0=n2+1
//    推导:假设度为1的结点个数为n1，那么二叉树的结点总数为n=n0+n1+n2
//    二叉树的边数T=n1+2*n2=n-1=n0+n1+n2-1(除了根结点以外所有结点头顶有一条边）
//真二叉树（Proper Binary Tree）：所有结点的度都要么为0，要么为2
//满二叉树（Full Binary Tree)：所有结点的度都要么为0，要么为2。且所有的叶子结点都在最后一层
//    在同样高度的二叉树中，满二叉树的叶子结点数量最多，总结点数量最多
//    满二叉树一定是真二叉树，真二叉树不一定是满二叉树
//    假设满二叉树高度为h(h>=1),那么
//    第i层的结点数量：2^(i-1)  叶子结点数量：2^(h-1)
//    总结点数量n=2^h-1 h=log2(n+1)
//完全二叉树（Complete Binary Tree）：叶子结点只会出现在最后2层，且最后1层的叶子结点都靠左对齐
//    完全二叉树从根结点至倒数第2层是一颗满二叉树
//    满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树
//    度为1的结点只有左子树
//    度为1的结点要么是1个，要么是0个
//    同样结点数量的二叉树，完全二叉树的高度最小
//    假设完全二叉树的高度为h（h>=1)，那么
//    至少有2^(h-1)个结点
//    向下取整（floor)  向上取整(ceiling)
//    h=floor(log2n)+1   h-1 <= log2n < h
public class BinaryTree {
    /*
     * 平衡：当结点数量固定时，左右子树的高度越接近，这颗二叉树就越平衡（高度越低）
     * 平衡二叉搜索树（Balanced Binary Search Tree）
     * 英文坚持为BBST
     * 经典常见的平衡二叉搜索树
     * AVL树---WindwosNT内核中广泛使用
     * 红黑树---C++STL（比如map，set）
     * java的TreeMap，TreeSet，HashMap,HashSet
     * Linux的进程调度
     * Ngix的timer管理
     * 一般也称它们为：自平衡的二叉搜索树（Self-balancing Binary Search）
     * */
}
