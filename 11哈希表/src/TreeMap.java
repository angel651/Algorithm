/**
 * @author boyas
 * @create 2021/6/27 13:04
 */
//哈希表也叫做散列表（hash有"剁碎"的意思）
// 它是如何实现高校处理数据的？
//添加，搜索，删除的流程都是类似的
//1.利用哈希函数生成key对应的index【O(1)】
//根据index操作定位数组元素【O(1)】
//哈希表是【空间换时间】的典型应用
//哈希函数，也叫做散列函数
//哈希表内部的数组元素，很多地方也叫Bucket(桶），整个数组叫Buckets或Bucket Array
//哈希冲突（Hash Collision)
//哈希冲突也叫做哈希碰撞
//2个不同的key，经过哈希函数计算出相同的结果
//key/=key2,hash(key1)=hash(key2)
//JDK1.8的哈希冲突解决方案
//默认使用单向链表将元素串起来
//在添加元素时，可能会由单向链表转为红黑树来存储元素
//比如当哈希表容量>=64且单向链表的结点数量大于8时
//当红黑树结点数量少到一定程度时，又会转为单向链表
//JDK1.8中的哈希表是使用链表+红黑树解决哈希冲突
//思考：这里为什么使用单链表？
//每次都是从头结点开始遍历
//单向链表比双向链表少一个指针，可以节省内存空间
//哈希函数
//1.先生成key的哈希值（必须是整数）
//2.再让key的哈希值跟数组的大小进行相关运算，生成一个索引值
//public int hash(Object key){
//    return hash_code(key)%table.length;
//}
//为了提高效率，可以使用&位运算取代%运算,(前提：将数组的长度设计为2的幂(2^n)
//public int hash(Object key){
//    return hash_code(key)&(table.length-1);
//}
//良好的哈希函数
//让哈希值更加均匀分布->减少哈希冲突次数->提升哈希表的性能
public class TreeMap {

}
